#+SETUPFILE: org-html-themes/setup/theme-readtheorg-local.setup

* 1 - Generic Introduction to Programming
** Notes
*** Basic Introduction to Programming Languages 
**** Python/Anaconda
**** Haskell
**** Visualization - ClojureScript
**** Java - OpenNLP
*** Introduction to CodeSharing and Community
**** Git
**** GitHub
**** GitLab
**** Pages
*** DataBases
**** SQLite3
**** Mongo
**** Neo4J
**** MySQL
**** Redis **
*** Leading to Good resources in 
**** Artificial Intelligence
**** Foundations of Computing
**** Data Science
* 2 - Introduction to Clojure
** Notes
* 3 - Setting up the Lab
** Notes
*** Setting up the Clojure and focusing initially only on the REPL
*** Later on we just move on to FileSystem/API/WebPage based work
* 4 - Alphabet
** Notes
** Alphanumeric characters in the word
*** cuerdas - only alphabets in the words

#+BEGIN_SRC clojure
  (require '[cuerdas.core :as cuerdas])


  (cuerdas/alpha? "word")


  (cuerdas/alpha-numeric? "word 123")

  (cuerdas/alnum? "word 123")

(cuerdas/letters? "汉语")
#+END_SRC

#+RESULTS:
: niltruefalsefalse

* 5 - Word
** Notes
** DEFINE a word
*** defining a simple word
#+BEGIN_SRC clojure

(def word "word")

#+END_SRC

#+RESULTS:
: #'user/word

** INDEX of an alphabet in a word
*** using the index of the alphabet
#+BEGIN_SRC clojure
(.indexOf  word "o")

#+END_SRC

#+RESULTS:
: 1

*** find the LAST index of a character
#+BEGIN_SRC clojure


#+END_SRC
** LENGTH of a word
*** get the length of a word
#+BEGIN_SRC clojure
(.length  word)

#+END_SRC

#+RESULTS:
: 4

*** native- empty? 
#+BEGIN_SRC clojure
(.isEmpty word)

#+END_SRC

#+RESULTS:
: false

** Get a SUBWORD
*** native - index-range SUBSTRING
#+BEGIN_SRC clojure

(.substring word 1 3)

#+END_SRC

#+RESULTS:
: or

*** native - SUBSEQUENCE

#+BEGIN_SRC clojure
(.subSequence word 1 3)
#+END_SRC

#+RESULTS:
: or

** Case of a word
*** native - uppercase
#+BEGIN_SRC clojure
(.toUpperCase word)

#+END_SRC

#+RESULTS:
: WORD

*** native - lowercase
#+BEGIN_SRC clojure
(.toLowerCase word)

#+END_SRC

#+RESULTS:
: word

** Dealing with whitespaces
*** native - trim
#+BEGIN_SRC clojure
(.trim "   word  ")

#+END_SRC

#+RESULTS:
: word
** Comparing words
*** 
** Words to Character Arrays
*** core
#+BEGIN_SRC clojure
(char )
(char? )
(chars)
(char-array)
(char-name-string)
(char-escape-string)

#+END_SRC
*** native
Here, the (.toCharArray ) method gives us a Java Array object

we can deal with an Array object using ( get ) method from Clojure

#+BEGIN_SRC clojure

(get (.toCharArray "word") 0)


#+END_SRC

#+RESULTS:
: \w
*** cuerdas

#+BEGIN_SRC clojure
 (require '[cuerdas.core :as cuerdas])


(cuerdas/chars "characters")

#+END_SRC

#+RESULTS:
: nil["c" "h" "a" "r" "a" "c" "t" "e" "r" "s" " " "i" "n" " "]

* 6 - Sentences
** Joining Words together
*** joining words
#+BEGIN_SRC clojure
(.concat "a" "b")

#+END_SRC

#+RESULTS:
: ab


#+BEGIN_SRC clojure

#+END_SRC

#+BEGIN_SRC clojure
(str "a" "b" "c")

#+END_SRC

#+RESULTS:
: abc


*** 
** Splitting a sentence
#+BEGIN_SRC clojure

(get (.split "name is bond" " ") 2)


#+END_SRC

#+RESULTS:
: bond
* LATER
** Java interop 
*** introduce all the native methods in this case
*** use StanfordNLP - java as an example
** Asking Questions from Clojure ( and Emacs? )
** Importing libraries and concept of namespaces in Clojure
** Regular Expressions
** Code Structure and Documentation
** Introduction to the DSL 
*** A basic overview of the DSL we've created to work with.
*** Need to provide a basic WordNet etc. integration for the Clojars.org package
** Our Understanding of a Language
*** The depth of chunking a language we try out.
*** Clarify that we abstract away from the Cultural Contexts in a language.
